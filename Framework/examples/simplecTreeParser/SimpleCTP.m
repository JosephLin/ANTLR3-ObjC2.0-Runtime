/** \file
 *  This OBJC source file was generated by $ANTLR version 3.2 Aug 17, 2010 17:18:07
 *
 *     -  From the grammar source file : SimpleCTP.g
 *     -                            On : 2010-08-18 08:13:05
 *     -           for the tree parser : SimpleCTPTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.2 Aug 17, 2010 17:18:07 SimpleCTP.g 2010-08-18 08:13:05

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "SimpleCTP.h"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_declaration_in_program49;

const unsigned long long FOLLOW_declaration_in_program49_data[] = { 0x0000000000000192LL};

static ANTLRBitSet *FOLLOW_variable_in_declaration69;

const unsigned long long FOLLOW_variable_in_declaration69_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_FUNC_DECL_in_declaration80;

const unsigned long long FOLLOW_FUNC_DECL_in_declaration80_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_functionHeader_in_declaration82;

const unsigned long long FOLLOW_functionHeader_in_declaration82_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_FUNC_DEF_in_declaration94;

const unsigned long long FOLLOW_FUNC_DEF_in_declaration94_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_functionHeader_in_declaration96;

const unsigned long long FOLLOW_functionHeader_in_declaration96_data[] = { 0x0000000000000200LL};

static ANTLRBitSet *FOLLOW_block_in_declaration98;

const unsigned long long FOLLOW_block_in_declaration98_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_VAR_DEF_in_variable119;

const unsigned long long FOLLOW_VAR_DEF_in_variable119_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_type_in_variable121;

const unsigned long long FOLLOW_type_in_variable121_data[] = { 0x0000000000000400LL};

static ANTLRBitSet *FOLLOW_declarator_in_variable123;

const unsigned long long FOLLOW_declarator_in_variable123_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_K_ID_in_declarator143;

const unsigned long long FOLLOW_K_ID_in_declarator143_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_FUNC_HDR_in_functionHeader164;

const unsigned long long FOLLOW_FUNC_HDR_in_functionHeader164_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_type_in_functionHeader166;

const unsigned long long FOLLOW_type_in_functionHeader166_data[] = { 0x0000000000000400LL};

static ANTLRBitSet *FOLLOW_K_ID_in_functionHeader168;

const unsigned long long FOLLOW_K_ID_in_functionHeader168_data[] = { 0x0000000000000020LL};

static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader170;

const unsigned long long FOLLOW_formalParameter_in_functionHeader170_data[] = { 0x0000000000000028LL};

static ANTLRBitSet *FOLLOW_ARG_DEF_in_formalParameter192;

const unsigned long long FOLLOW_ARG_DEF_in_formalParameter192_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_type_in_formalParameter194;

const unsigned long long FOLLOW_type_in_formalParameter194_data[] = { 0x0000000000000400LL};

static ANTLRBitSet *FOLLOW_declarator_in_formalParameter196;

const unsigned long long FOLLOW_declarator_in_formalParameter196_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_set_in_type0;

const unsigned long long FOLLOW_set_in_type0_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_BLOCK_in_block279;

const unsigned long long FOLLOW_BLOCK_in_block279_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_variable_in_block281;

const unsigned long long FOLLOW_variable_in_block281_data[] = { 0x000000000007CE18LL};

static ANTLRBitSet *FOLLOW_stat_in_block284;

const unsigned long long FOLLOW_stat_in_block284_data[] = { 0x000000000007CE08LL};

static ANTLRBitSet *FOLLOW_forStat_in_stat298;

const unsigned long long FOLLOW_forStat_in_stat298_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_expr_in_stat306;

const unsigned long long FOLLOW_expr_in_stat306_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_block_in_stat314;

const unsigned long long FOLLOW_block_in_stat314_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_K_FOR_in_forStat334;

const unsigned long long FOLLOW_K_FOR_in_forStat334_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_expr_in_forStat336;

const unsigned long long FOLLOW_expr_in_forStat336_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_forStat338;

const unsigned long long FOLLOW_expr_in_forStat338_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_forStat340;

const unsigned long long FOLLOW_expr_in_forStat340_data[] = { 0x0000000000000200LL};

static ANTLRBitSet *FOLLOW_block_in_forStat342;

const unsigned long long FOLLOW_block_in_forStat342_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_K_EQEQ_in_expr358;

const unsigned long long FOLLOW_K_EQEQ_in_expr358_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_expr_in_expr360;

const unsigned long long FOLLOW_expr_in_expr360_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_expr362;

const unsigned long long FOLLOW_expr_in_expr362_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_K_LT_in_expr374;

const unsigned long long FOLLOW_K_LT_in_expr374_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_expr_in_expr376;

const unsigned long long FOLLOW_expr_in_expr376_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_expr378;

const unsigned long long FOLLOW_expr_in_expr378_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_K_PLUS_in_expr390;

const unsigned long long FOLLOW_K_PLUS_in_expr390_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_expr_in_expr392;

const unsigned long long FOLLOW_expr_in_expr392_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_expr394;

const unsigned long long FOLLOW_expr_in_expr394_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_K_EQ_in_expr406;

const unsigned long long FOLLOW_K_EQ_in_expr406_data[] = { 0x0000000000000004LL};

static ANTLRBitSet *FOLLOW_K_ID_in_expr408;

const unsigned long long FOLLOW_K_ID_in_expr408_data[] = { 0x0000000000078C00LL};

static ANTLRBitSet *FOLLOW_expr_in_expr412;

const unsigned long long FOLLOW_expr_in_expr412_data[] = { 0x0000000000000008LL};

static ANTLRBitSet *FOLLOW_atom_in_expr425;

const unsigned long long FOLLOW_atom_in_expr425_data[] = { 0x0000000000000002LL};

static ANTLRBitSet *FOLLOW_set_in_atom0;

const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x0000000000000002LL};



#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule return scopes start
@implementation SimpleCTP_expr_return
@synthesize tree;
+ (SimpleCTP_expr_return *)newSimpleCTP_expr_return
{
    return [[[SimpleCTP_expr_return alloc] init] retain];
}




@end


@implementation SimpleCTP  // line 610

+ (void) initialize
{
    FOLLOW_declaration_in_program49 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declaration_in_program49_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_declaration69 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_declaration69_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_DECL_in_declaration80 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_DECL_in_declaration80_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration82 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration82_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_DEF_in_declaration94 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_DEF_in_declaration94_data Count:(NSUInteger)1] retain];
    FOLLOW_functionHeader_in_declaration96 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_functionHeader_in_declaration96_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_declaration98 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_declaration98_data Count:(NSUInteger)1] retain];
    FOLLOW_VAR_DEF_in_variable119 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_VAR_DEF_in_variable119_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_variable121 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_variable121_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_variable123 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_variable123_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_declarator143 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_declarator143_data Count:(NSUInteger)1] retain];
    FOLLOW_FUNC_HDR_in_functionHeader164 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_FUNC_HDR_in_functionHeader164_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_functionHeader166 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_functionHeader166_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_functionHeader168 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_functionHeader168_data Count:(NSUInteger)1] retain];
    FOLLOW_formalParameter_in_functionHeader170 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_formalParameter_in_functionHeader170_data Count:(NSUInteger)1] retain];
    FOLLOW_ARG_DEF_in_formalParameter192 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ARG_DEF_in_formalParameter192_data Count:(NSUInteger)1] retain];
    FOLLOW_type_in_formalParameter194 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_formalParameter194_data Count:(NSUInteger)1] retain];
    FOLLOW_declarator_in_formalParameter196 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_formalParameter196_data Count:(NSUInteger)1] retain];
    FOLLOW_set_in_type0 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_type0_data Count:(NSUInteger)1] retain];
    FOLLOW_BLOCK_in_block279 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_BLOCK_in_block279_data Count:(NSUInteger)1] retain];
    FOLLOW_variable_in_block281 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_block281_data Count:(NSUInteger)1] retain];
    FOLLOW_stat_in_block284 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_stat_in_block284_data Count:(NSUInteger)1] retain];
    FOLLOW_forStat_in_stat298 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_forStat_in_stat298_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_stat306 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_stat306_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_stat314 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_stat314_data Count:(NSUInteger)1] retain];
    FOLLOW_K_FOR_in_forStat334 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_FOR_in_forStat334_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat336 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat336_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat338 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat338_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_forStat340 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_forStat340_data Count:(NSUInteger)1] retain];
    FOLLOW_block_in_forStat342 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_block_in_forStat342_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQEQ_in_expr358 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQEQ_in_expr358_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr360 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr360_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr362 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr362_data Count:(NSUInteger)1] retain];
    FOLLOW_K_LT_in_expr374 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LT_in_expr374_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr376 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr376_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr378 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr378_data Count:(NSUInteger)1] retain];
    FOLLOW_K_PLUS_in_expr390 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_PLUS_in_expr390_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr392 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr392_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr394 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr394_data Count:(NSUInteger)1] retain];
    FOLLOW_K_EQ_in_expr406 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_EQ_in_expr406_data Count:(NSUInteger)1] retain];
    FOLLOW_K_ID_in_expr408 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_expr408_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_expr412 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr412_data Count:(NSUInteger)1] retain];
    FOLLOW_atom_in_expr425 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_atom_in_expr425_data Count:(NSUInteger)1] retain];
    FOLLOW_set_in_atom0 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_atom0_data Count:(NSUInteger)1] retain];

    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"VAR_DEF", @"ARG_DEF", @"FUNC_HDR", @"FUNC_DECL", @"FUNC_DEF", @"BLOCK", 
 @"K_ID", @"K_INT", @"K_CHAR", @"K_VOID", @"K_FOR", @"K_EQ", @"K_EQEQ", 
 @"K_LT", @"K_PLUS", @"K_INT_TYPE", @"WS", @"';'", @"'('", @"','", @"')'", 
 @"'{'", @"'}'", nil] retain]];
}

+ (SimpleCTP *)newSimpleCTP:(id<ANTLRTreeNodeStream>)aStream
{

    return [[SimpleCTP alloc] initWithStream:aStream];

}


- (id) initWithStream:(id<ANTLRTreeNodeStream>)aStream
{
    if ((self = [super initWithStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:12+1] retain]]) != nil) {


                                                                                                        
    }
    return self;
}

- (void) dealloc
{
    [super dealloc];
}
// start actions.actionScope.methods
// start methods()
// start rules
/*
 * $ANTLR start program
 * SimpleCTP.g:8:1: program : ( declaration )+ ;
 */
- (void) program
{
    @try {
        // SimpleCTP.g:9:5: ( ( declaration )+ ) // ruleBlockSingleAlt
        // SimpleCTP.g:9:9: ( declaration )+ // alt
        {
        // SimpleCTP.g:9:9: ( declaration )+ // positiveClosureBlock
        NSInteger cnt1=0;
        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0==VAR_DEF||(LA1_0>=FUNC_DECL && LA1_0<=FUNC_DEF)) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // SimpleCTP.g:9:9: declaration // alt
                    {
                    [self pushFollow:FOLLOW_declaration_in_program49];
                    [self declaration];
                    [self popFollow];

                      /* element() */
                     /* elements */
                    }
                    break;

                default :
                    if ( cnt1 >= 1 )
                        goto loop1;
                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:1];
                    @throw eee;
            }
            cnt1++;
        } while (YES);
        loop1: ;
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end program */
/*
 * $ANTLR start declaration
 * SimpleCTP.g:12:1: declaration : ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) );
 */
- (void) declaration
{
    @try {
        // SimpleCTP.g:13:5: ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) ) //ruleblock
        NSInteger alt2=3;
        switch ([input LA:1]) {
            case VAR_DEF: ;
                {
                alt2=1;
                }
                break;
            case FUNC_DECL: ;
                {
                alt2=2;
                }
                break;
            case FUNC_DEF: ;
                {
                alt2=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:2 state:0 stream:input];
            @throw nvae;
        }

        switch (alt2) {
            case 1 : ;
                // SimpleCTP.g:13:9: variable // alt
                {
                [self pushFollow:FOLLOW_variable_in_declaration69];
                [self variable];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // SimpleCTP.g:14:9: ^( FUNC_DECL functionHeader ) // alt
                {
                [self match:input TokenType:FUNC_DECL Follow:FOLLOW_FUNC_DECL_in_declaration80];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    [self pushFollow:FOLLOW_functionHeader_in_declaration82];
                    [self functionHeader];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 /* elements */
                }
                break;
            case 3 : ;
                // SimpleCTP.g:15:9: ^( FUNC_DEF functionHeader block ) // alt
                {
                [self match:input TokenType:FUNC_DEF Follow:FOLLOW_FUNC_DEF_in_declaration94];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    [self pushFollow:FOLLOW_functionHeader_in_declaration96];
                    [self functionHeader];
                    [self popFollow];

                      /* element() */
                    [self pushFollow:FOLLOW_block_in_declaration98];
                    [self block];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end declaration */
/*
 * $ANTLR start variable
 * SimpleCTP.g:18:1: variable : ^( VAR_DEF type declarator ) ;
 */
- (void) variable
{
    @try {
        // SimpleCTP.g:19:5: ( ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:19:9: ^( VAR_DEF type declarator ) // alt
        {
        [self match:input TokenType:VAR_DEF Follow:FOLLOW_VAR_DEF_in_variable119];   /* element() */

            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
            [self pushFollow:FOLLOW_type_in_variable121];
            [self type];
            [self popFollow];

              /* element() */
            [self pushFollow:FOLLOW_declarator_in_variable123];
            [self declarator];
            [self popFollow];

              /* element() */

            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end variable */
/*
 * $ANTLR start declarator
 * SimpleCTP.g:22:1: declarator : K_ID ;
 */
- (void) declarator
{
    @try {
        // SimpleCTP.g:23:5: ( K_ID ) // ruleBlockSingleAlt
        // SimpleCTP.g:23:9: K_ID // alt
        {
        [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator143];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end declarator */
/*
 * $ANTLR start functionHeader
 * SimpleCTP.g:26:1: functionHeader : ^( FUNC_HDR type K_ID ( formalParameter )+ ) ;
 */
- (void) functionHeader
{
    @try {
        // SimpleCTP.g:27:5: ( ^( FUNC_HDR type K_ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:27:9: ^( FUNC_HDR type K_ID ( formalParameter )+ ) // alt
        {
        [self match:input TokenType:FUNC_HDR Follow:FOLLOW_FUNC_HDR_in_functionHeader164];   /* element() */

            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
            [self pushFollow:FOLLOW_type_in_functionHeader166];
            [self type];
            [self popFollow];

              /* element() */
            [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader168];   /* element() */
            // SimpleCTP.g:27:30: ( formalParameter )+ // positiveClosureBlock
            NSInteger cnt3=0;
            do {
                NSInteger alt3=2;
                NSInteger LA3_0 = [input LA:1];
                if ( (LA3_0==ARG_DEF) ) {
                    alt3=1;
                }


                switch (alt3) {
                    case 1 : ;
                        // SimpleCTP.g:27:30: formalParameter // alt
                        {
                        [self pushFollow:FOLLOW_formalParameter_in_functionHeader170];
                        [self formalParameter];
                        [self popFollow];

                          /* element() */
                         /* elements */
                        }
                        break;

                    default :
                        if ( cnt3 >= 1 )
                            goto loop3;
                        ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:3];
                        @throw eee;
                }
                cnt3++;
            } while (YES);
            loop3: ;
              /* element() */

            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end functionHeader */
/*
 * $ANTLR start formalParameter
 * SimpleCTP.g:30:1: formalParameter : ^( ARG_DEF type declarator ) ;
 */
- (void) formalParameter
{
    @try {
        // SimpleCTP.g:31:5: ( ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:31:9: ^( ARG_DEF type declarator ) // alt
        {
        [self match:input TokenType:ARG_DEF Follow:FOLLOW_ARG_DEF_in_formalParameter192];   /* element() */

            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
            [self pushFollow:FOLLOW_type_in_formalParameter194];
            [self type];
            [self popFollow];

              /* element() */
            [self pushFollow:FOLLOW_declarator_in_formalParameter196];
            [self declarator];
            [self popFollow];

              /* element() */

            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end formalParameter */
/*
 * $ANTLR start type
 * SimpleCTP.g:34:1: type : ( K_INT | K_CHAR | K_VOID | K_ID );
 */
- (void) type
{
    @try {
        // SimpleCTP.g:35:5: ( K_INT | K_CHAR | K_VOID | K_ID ) // ruleBlockSingleAlt
        // SimpleCTP.g: // alt
        {
        if (([input LA:1] >= K_ID && [input LA:1] <= K_VOID)) {
            [input consume];
            [state setIsErrorRecovery:NO];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
            @throw mse;
        }
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end type */
/*
 * $ANTLR start block
 * SimpleCTP.g:41:1: block : ^( BLOCK ( variable )* ( stat )* ) ;
 */
- (void) block
{
    @try {
        // SimpleCTP.g:42:5: ( ^( BLOCK ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:42:9: ^( BLOCK ( variable )* ( stat )* ) // alt
        {
        [self match:input TokenType:BLOCK Follow:FOLLOW_BLOCK_in_block279];   /* element() */

        if ( [input LA:1] == ANTLRTokenTypeDOWN ) {
            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
            do {
                NSInteger alt4=2;
                NSInteger LA4_0 = [input LA:1];
                if ( (LA4_0==VAR_DEF) ) {
                    alt4=1;
                }


                switch (alt4) {
                    case 1 : ;
                        // SimpleCTP.g:42:17: variable // alt
                        {
                        [self pushFollow:FOLLOW_variable_in_block281];
                        [self variable];
                        [self popFollow];

                          /* element() */
                         /* elements */
                        }
                        break;

                    default :
                        goto loop4;
                }
            } while (YES);
            loop4: ;
              /* element() */
            do {
                NSInteger alt5=2;
                NSInteger LA5_0 = [input LA:1];
                if ( ((LA5_0>=BLOCK && LA5_0<=K_INT)||(LA5_0>=K_FOR && LA5_0<=K_PLUS)) ) {
                    alt5=1;
                }


                switch (alt5) {
                    case 1 : ;
                        // SimpleCTP.g:42:27: stat // alt
                        {
                        [self pushFollow:FOLLOW_stat_in_block284];
                        [self stat];
                        [self popFollow];

                          /* element() */
                         /* elements */
                        }
                        break;

                    default :
                        goto loop5;
                }
            } while (YES);
            loop5: ;
              /* element() */

            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil]; 
        }  /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end block */
/*
 * $ANTLR start stat
 * SimpleCTP.g:45:1: stat : ( forStat | expr | block );
 */
- (void) stat
{
    @try {
        // SimpleCTP.g:45:5: ( forStat | expr | block ) //ruleblock
        NSInteger alt6=3;
        switch ([input LA:1]) {
            case K_FOR: ;
                {
                alt6=1;
                }
                break;
            case K_ID: ;
            case K_INT: ;
            case K_EQ: ;
            case K_EQEQ: ;
            case K_LT: ;
            case K_PLUS: ;
                {
                alt6=2;
                }
                break;
            case BLOCK: ;
                {
                alt6=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:6 state:0 stream:input];
            @throw nvae;
        }

        switch (alt6) {
            case 1 : ;
                // SimpleCTP.g:45:7: forStat // alt
                {
                [self pushFollow:FOLLOW_forStat_in_stat298];
                [self forStat];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // SimpleCTP.g:46:7: expr // alt
                {
                [self pushFollow:FOLLOW_expr_in_stat306];
                [self expr];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;
            case 3 : ;
                // SimpleCTP.g:47:7: block // alt
                {
                [self pushFollow:FOLLOW_block_in_stat314];
                [self block];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end stat */
/*
 * $ANTLR start forStat
 * SimpleCTP.g:50:1: forStat : ^( K_FOR expr expr expr block ) ;
 */
- (void) forStat
{
    @try {
        // SimpleCTP.g:51:5: ( ^( K_FOR expr expr expr block ) ) // ruleBlockSingleAlt
        // SimpleCTP.g:51:9: ^( K_FOR expr expr expr block ) // alt
        {
        [self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat334];   /* element() */

            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
            [self pushFollow:FOLLOW_expr_in_forStat336];
            [self expr];
            [self popFollow];

              /* element() */
            [self pushFollow:FOLLOW_expr_in_forStat338];
            [self expr];
            [self popFollow];

              /* element() */
            [self pushFollow:FOLLOW_expr_in_forStat340];
            [self expr];
            [self popFollow];

              /* element() */
            [self pushFollow:FOLLOW_block_in_forStat342];
            [self block];
            [self popFollow];

              /* element() */

            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end forStat */
/*
 * $ANTLR start expr
 * SimpleCTP.g:54:1: expr : ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom );
 */
- (SimpleCTP_expr_return *) expr
{
    SimpleCTP_expr_return * retval = [SimpleCTP_expr_return newSimpleCTP_expr_return];
    [retval setStart:[input LT:1]];

    @try {
        ANTLRCommonTree * K_ID1 = nil;
        SimpleCTP_expr_return * e = nil;


        // SimpleCTP.g:54:5: ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom ) //ruleblock
        NSInteger alt7=5;
        switch ([input LA:1]) {
            case K_EQEQ: ;
                {
                alt7=1;
                }
                break;
            case K_LT: ;
                {
                alt7=2;
                }
                break;
            case K_PLUS: ;
                {
                alt7=3;
                }
                break;
            case K_EQ: ;
                {
                alt7=4;
                }
                break;
            case K_ID: ;
            case K_INT: ;
                {
                alt7=5;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:7 state:0 stream:input];
            @throw nvae;
        }

        switch (alt7) {
            case 1 : ;
                // SimpleCTP.g:54:9: ^( K_EQEQ expr expr ) // alt
                {
                [self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_expr358];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    [self pushFollow:FOLLOW_expr_in_expr360];
                    [self expr];
                    [self popFollow];

                      /* element() */
                    [self pushFollow:FOLLOW_expr_in_expr362];
                    [self expr];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 /* elements */
                }
                break;
            case 2 : ;
                // SimpleCTP.g:55:9: ^( K_LT expr expr ) // alt
                {
                [self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_expr374];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    [self pushFollow:FOLLOW_expr_in_expr376];
                    [self expr];
                    [self popFollow];

                      /* element() */
                    [self pushFollow:FOLLOW_expr_in_expr378];
                    [self expr];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 /* elements */
                }
                break;
            case 3 : ;
                // SimpleCTP.g:56:9: ^( K_PLUS expr expr ) // alt
                {
                [self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_expr390];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    [self pushFollow:FOLLOW_expr_in_expr392];
                    [self expr];
                    [self popFollow];

                      /* element() */
                    [self pushFollow:FOLLOW_expr_in_expr394];
                    [self expr];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 /* elements */
                }
                break;
            case 4 : ;
                // SimpleCTP.g:57:9: ^( K_EQ K_ID e= expr ) // alt
                {
                [self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_expr406];   /* element() */

                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; 
                    K_ID1=(ANTLRCommonTree *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_expr408];   /* element() */
                    [self pushFollow:FOLLOW_expr_in_expr412];
                    e = [self expr];
                    [self popFollow];

                      /* element() */

                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
                 NSLog(@"assigning %@ to variable %@", (e!=nil?[[input getTokenStream] toStringFromStart:[[input getTreeAdaptor] getTokenStartIndex:[e getStart]]
                         ToEnd:[[input getTreeAdaptor] getTokenStopIndex:[e getStart]]]:nil), (K_ID1!=nil?[K_ID1 getText]:0));   /* element() */
                 /* elements */
                }
                break;
            case 5 : ;
                // SimpleCTP.g:58:9: atom // alt
                {
                [self pushFollow:FOLLOW_atom_in_expr425];
                [self atom];
                [self popFollow];

                  /* element() */
                 /* elements */
                }
                break;

        }
        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return retval;
}
/* $ANTLR end expr */
/*
 * $ANTLR start atom
 * SimpleCTP.g:61:1: atom : ( K_ID | K_INT );
 */
- (void) atom
{
    @try {
        // SimpleCTP.g:62:5: ( K_ID | K_INT ) // ruleBlockSingleAlt
        // SimpleCTP.g: // alt
        {
        if (([input LA:1] >= K_ID && [input LA:1] <= K_INT)) {
            [input consume];
            [state setIsErrorRecovery:NO];
        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
            @throw mse;
        }
          /* element() */
         /* elements */
        }

        // token+rule list labels

    }
    @catch (ANTLRRecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }    @finally {
    }
    return ;
}
/* $ANTLR end atom */

@end // end of SimpleCTP implementation line 669

/* End of code
 * =============================================================================
 */
